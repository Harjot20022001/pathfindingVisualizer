{"version":3,"sources":["Node/Node.jsx","Algorithms/dijkstra.js","PathfindingVisualizer/PathfindingVisualizer.jsx","Algorithms/depth-first-search.js","MazeAlgo/simpleStairPattern.js","MazeAlgo/simpleMaze.js","App.js","index.js"],"names":["Node","_this$props","this","props","col","isFinish","isStart","isWall","onMouseDown","onMouseEnter","onMouseUp","row","extraClassName","react_default","a","createElement","id","concat","className","Component","dijkstra","grid","startNode","finishNode","visitedNodesInOrder","distance","unvisitedNodes","_step2","nodes","_iterator2","_createForOfIteratorHelper","s","n","done","_step3","value","_iterator3","node","push","err","e","f","getAllNodes","length","sortNodesByDistance","closestNode","shift","Infinity","slice","isVisited","updateUnvisitedNeighbors","sort","nodeA","nodeB","_step","_iterator","neighbors","filter","neighbor","getUnvisitedNeighbors","previousNode","PathfindingVisualizer","_this","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","state","mouseIsPressed","isVisualize","newGrid","getNewGridWithWallToggled","setState","getInitialGrid","_this2","_loop","i","setTimeout","animateShortestPath","v","document","getElementById","_ret","nodesInShortestPathOrder","_this3","_loop2","_ret2","_loop3","visitedWallsInOrder","_this4","_loop4","handleMouseDown","handleMouseUp","walls","currentNode","unshift","getNodesInShortestPathOrder","animateDijkstra","depthFirstSearch","depth_first_search_createForOfIteratorHelper","newVisitedNodesInOrder","animateDFS","node1","node2","node3","j","simpleStairPattern","animateMaze","rows","cols","Math","floor","random","simpleMaze","animateSimpleMaze","_this5","_this$state","Navbar","navClass","bg","expand","Container","Brand","onClick","window","location","reload","href","Toggle","aria-controls","Collapse","Nav","Button","visualizeDijkstra","variant","visualizeDFS","Dropdown","Menu","Item","visualizeSimpleMaze","visualizeStairMaze","map","rowIdx","key","nodeIdx","Node_Node_Node","handleMouseEnter","currentRow","createNode","newNode","objectSpread","App","PathfindingVisualizer_PathfindingVisualizer_PathfindingVisualizer","ReactDOM","createRoot","render","StrictMode","src_App"],"mappings":"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","file":"static/js/main.6fd95546.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\n\r\nimport \"./Node.css\";\r\n\r\nexport default class Node extends Component {\r\n  render() {\r\n    const {\r\n      col,\r\n      isFinish,\r\n      isStart,\r\n      isWall,\r\n      onMouseDown,\r\n      onMouseEnter,\r\n      onMouseUp,\r\n      row,\r\n    } = this.props;\r\n    const extraClassName = isFinish\r\n      ? \"node-finish\"\r\n      : isStart\r\n      ? \"node-start\"\r\n      : isWall\r\n      ? \"node-wall\"\r\n      : \"\";\r\n\r\n    return (\r\n      <div\r\n        id={`node-${row}-${col}`}\r\n        className={`node ${extraClassName}`}\r\n        onMouseDown={() => onMouseDown(row, col)}\r\n        onMouseEnter={() => onMouseEnter(row, col)}\r\n        onMouseUp={() => onMouseUp()}\r\n      ></div>\r\n    );\r\n  }\r\n}\r\n","// Performs Dijkstra's algorithm; returns *all* nodes in the order\r\n// in which they were visited. Also makes nodes point back to their\r\n// previous node, effectively allowing us to compute the shortest path\r\n// by backtracking from the finish node.\r\n\r\nexport function dijkstra(grid, startNode, finishNode) {\r\n  const visitedNodesInOrder = [];\r\n  startNode.distance = 0;\r\n  const unvisitedNodes = getAllNodes(grid);\r\n  while (!!unvisitedNodes.length) {\r\n    sortNodesByDistance(unvisitedNodes);\r\n    const closestNode = unvisitedNodes.shift();\r\n    // If we encounter a wall, we skip it.\r\n    if (closestNode.isWall) continue;\r\n    // If the closest node is at a distance of infinity,\r\n    // we must be trapped and should therefore stop.\r\n    if (closestNode.distance === Infinity)\r\n      return visitedNodesInOrder.slice(1, visitedNodesInOrder.length - 1);\r\n    closestNode.isVisited = true;\r\n    visitedNodesInOrder.push(closestNode);\r\n    if (closestNode === finishNode)\r\n      return visitedNodesInOrder.slice(1, visitedNodesInOrder.length - 1);\r\n    updateUnvisitedNeighbors(closestNode, grid);\r\n  }\r\n}\r\n\r\nfunction sortNodesByDistance(unvisitedNodes) {\r\n  unvisitedNodes.sort((nodeA, nodeB) => nodeA.distance - nodeB.distance);\r\n}\r\n\r\nfunction updateUnvisitedNeighbors(node, grid) {\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(node, grid);\r\n  for (const neighbor of unvisitedNeighbors) {\r\n    neighbor.distance = node.distance + 1;\r\n    neighbor.previousNode = node;\r\n  }\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n\r\nfunction getAllNodes(grid) {\r\n  const nodes = [];\r\n  for (const row of grid) {\r\n    for (const node of row) {\r\n      nodes.push(node);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n\r\n// Backtracks from the finishNode to find the shortest path.\r\n// Only works when called *after* the dijkstra method above.\r\nexport function getNodesInShortestPathOrder(finishNode) {\r\n  const nodesInShortestPathOrder = [];\r\n  let currentNode = finishNode;\r\n  while (currentNode !== null) {\r\n    nodesInShortestPathOrder.unshift(currentNode);\r\n    currentNode = currentNode.previousNode;\r\n  }\r\n  return nodesInShortestPathOrder.slice(1, nodesInShortestPathOrder.length - 1);\r\n}\r\n","import React, { Component } from \"react\";\r\nimport Node from \"../Node/Node\";\r\nimport \"./PathfindingVisualizer.css\";\r\nimport { dijkstra, getNodesInShortestPathOrder } from \"../Algorithms/dijkstra\";\r\nimport { Navbar, Nav, Container, Button, Dropdown } from \"react-bootstrap\";\r\nimport \"bootstrap/dist/css/bootstrap.min.css\";\r\nimport { depthFirstSearch } from \"../Algorithms/depth-first-search\";\r\nimport { simpleStairPattern } from \"../MazeAlgo/simpleStairPattern\";\r\nimport { simpleMaze } from \"../MazeAlgo/simpleMaze\";\r\n\r\nconst START_NODE_ROW = 12;\r\nconst START_NODE_COL = 17;\r\nconst FINISH_NODE_ROW = 12;\r\nconst FINISH_NODE_COL = 58;\r\n\r\nexport default class PathfindingVisualizer extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {\r\n      grid: [],\r\n      mouseIsPressed: false,\r\n      isVisualize: false,\r\n    };\r\n  }\r\n\r\n  handleMouseDown(row, col) {\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid, mouseIsPressed: true });\r\n  }\r\n\r\n  handleMouseEnter(row, col) {\r\n    if (!this.state.mouseIsPressed) return;\r\n    const newGrid = getNewGridWithWallToggled(this.state.grid, row, col);\r\n    this.setState({ grid: newGrid });\r\n  }\r\n\r\n  handleMouseUp() {\r\n    this.setState({ mouseIsPressed: false });\r\n  }\r\n\r\n  componentDidMount() {\r\n    const grid = getInitialGrid();\r\n\r\n    this.setState({ grid });\r\n  }\r\n\r\n  animateDFS(visitedNodesInOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(visitedNodesInOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder) {\r\n    for (let i = 0; i <= visitedNodesInOrder.length; i++) {\r\n      if (i === visitedNodesInOrder.length) {\r\n        setTimeout(() => {\r\n          this.animateShortestPath(nodesInShortestPathOrder);\r\n        }, 10 * i);\r\n        return;\r\n      }\r\n      setTimeout(() => {\r\n        const node = visitedNodesInOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-visited\";\r\n      }, 10 * i);\r\n    }\r\n  }\r\n\r\n  animateShortestPath(nodesInShortestPathOrder) {\r\n    for (let i = 0; i < nodesInShortestPathOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = nodesInShortestPathOrder[i];\r\n        document.getElementById(`node-${node.row}-${node.col}`).className =\r\n          \"node node-path\";\r\n      }, 50 * i);\r\n    }\r\n  }\r\n\r\n  animateMaze(visitedWallsInOrder) {\r\n    for (let i = 0; i < visitedWallsInOrder.length; i++) {\r\n      setTimeout(() => {\r\n        const node = visitedWallsInOrder[i];\r\n        this.handleMouseDown(node.row, node.col);\r\n        this.handleMouseUp();\r\n      }, 30 * i);\r\n    }\r\n  }\r\n\r\n  animateSimpleMaze(walls) {\r\n    for (let i = 0; i < walls.length; i++) {\r\n      const node = walls[i];\r\n      this.handleMouseDown(node.row, node.col);\r\n      this.handleMouseUp();\r\n    }\r\n  }\r\n\r\n  visualizeDijkstra() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedNodesInOrder = dijkstra(grid, startNode, finishNode);\r\n    const nodesInShortestPathOrder = getNodesInShortestPathOrder(finishNode);\r\n    this.setState({ isVisualize: true });\r\n    this.animateDijkstra(visitedNodesInOrder, nodesInShortestPathOrder);\r\n  }\r\n\r\n  visualizeDFS() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const nodes = [];\r\n    const visitedNodesInOrder = depthFirstSearch(\r\n      grid,\r\n      startNode,\r\n      finishNode,\r\n      nodes\r\n    );\r\n    this.setState({ isVisualize: true });\r\n    this.animateDFS(visitedNodesInOrder);\r\n  }\r\n\r\n  visualizeStairMaze() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const visitedWallsInOrder = simpleStairPattern(grid, startNode, finishNode);\r\n    this.animateMaze(visitedWallsInOrder);\r\n  }\r\n\r\n  visualizeSimpleMaze() {\r\n    const { grid } = this.state;\r\n    const startNode = grid[START_NODE_ROW][START_NODE_COL];\r\n    const finishNode = grid[FINISH_NODE_ROW][FINISH_NODE_COL];\r\n    const rows = 29;\r\n    const cols = 76;\r\n    const walls = simpleMaze(grid, startNode, finishNode, rows, cols);\r\n    this.animateSimpleMaze(walls);\r\n  }\r\n\r\n  render() {\r\n    const { grid, mouseIsPressed, isVisualize } = this.state;\r\n    return (\r\n      <div>\r\n        <Navbar className={navClass(isVisualize)} bg=\"light\" expand=\"lg\">\r\n          <Container>\r\n            <Navbar.Brand\r\n              onClick={() => {\r\n                window.location.reload(false);\r\n              }}\r\n              href=\"#home\"\r\n            >\r\n              Pathfinding Visualizer\r\n            </Navbar.Brand>\r\n            <Navbar.Toggle aria-controls=\"basic-navbar-nav\" />\r\n            <Navbar.Collapse id=\"basic-navbar-nav\">\r\n              <Nav className=\"me-auto\">\r\n                <Button onClick={() => this.visualizeDijkstra()} variant=\"dark\">\r\n                  Visualize Dijkstra\r\n                </Button>\r\n                &nbsp;\r\n                <Button variant=\"dark\" onClick={() => this.visualizeDFS()}>\r\n                  Visualize DFS\r\n                </Button>\r\n                &nbsp;\r\n                <Button variant=\"dark\">Visualize A*</Button>\r\n                &nbsp; &nbsp;\r\n                <Dropdown>\r\n                  <Dropdown.Toggle\r\n                    id=\"dropdown-button-dark\"\r\n                    variant=\"outline-dark\"\r\n                  >\r\n                    Generate Maze\r\n                  </Dropdown.Toggle>\r\n\r\n                  <Dropdown.Menu variant=\"dark\">\r\n                    <Dropdown.Item\r\n                      onClick={() => this.visualizeSimpleMaze()}\r\n                      href=\"#/action-1\"\r\n                    >\r\n                      Simple Maze\r\n                    </Dropdown.Item>\r\n                    <Dropdown.Item\r\n                      onClick={() => this.visualizeStairMaze()}\r\n                      href=\"#/action-2\"\r\n                    >\r\n                      Stair Pattern\r\n                    </Dropdown.Item>\r\n                  </Dropdown.Menu>\r\n                </Dropdown>\r\n              </Nav>\r\n            </Navbar.Collapse>\r\n          </Container>\r\n        </Navbar>\r\n        <Button\r\n          className=\"reset-button\"\r\n          onClick={() => {\r\n            window.location.reload(false);\r\n          }}\r\n          variant=\"outline-danger\"\r\n        >\r\n          Reset\r\n        </Button>\r\n        <div className={extraClassName(isVisualize)}>\r\n          {grid.map((row, rowIdx) => {\r\n            return (\r\n              <div key={rowIdx}>\r\n                {row.map((node, nodeIdx) => {\r\n                  const { row, col, isFinish, isStart, isWall } = node;\r\n                  return (\r\n                    <Node\r\n                      key={nodeIdx}\r\n                      col={col}\r\n                      isFinish={isFinish}\r\n                      isStart={isStart}\r\n                      isWall={isWall}\r\n                      mouseIsPressed={mouseIsPressed}\r\n                      onMouseDown={(row, col) => this.handleMouseDown(row, col)}\r\n                      onMouseEnter={(row, col) =>\r\n                        this.handleMouseEnter(row, col)\r\n                      }\r\n                      onMouseUp={() => this.handleMouseUp()}\r\n                      row={row}\r\n                    ></Node>\r\n                  );\r\n                })}\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst navClass = (isVisualize) => {\r\n  if (isVisualize === true) {\r\n    return \"nav-disabled\";\r\n  }\r\n};\r\n\r\nconst extraClassName = (isVisualize) => {\r\n  if (isVisualize === true) {\r\n    return \"grid-disabled\";\r\n  }\r\n  return \"grid\";\r\n};\r\n\r\nconst getInitialGrid = () => {\r\n  const grid = [];\r\n  for (let row = 0; row < 29; row++) {\r\n    const currentRow = [];\r\n    for (let col = 0; col < 76; col++) {\r\n      currentRow.push(createNode(col, row));\r\n    }\r\n    grid.push(currentRow);\r\n  }\r\n  return grid;\r\n};\r\n\r\nconst createNode = (col, row) => {\r\n  return {\r\n    col,\r\n    row,\r\n    isStart: row === START_NODE_ROW && col === START_NODE_COL,\r\n    isFinish: row === FINISH_NODE_ROW && col === FINISH_NODE_COL,\r\n    distance: Infinity,\r\n    isVisited: false,\r\n    isWall: false,\r\n    previousNode: null,\r\n  };\r\n};\r\n\r\nconst getNewGridWithWallToggled = (grid, row, col) => {\r\n  const newGrid = grid.slice();\r\n  const node = newGrid[row][col];\r\n  const newNode = {\r\n    ...node,\r\n    isWall: !node.isWall,\r\n  };\r\n  newGrid[row][col] = newNode;\r\n  return newGrid;\r\n};\r\n","export function depthFirstSearch(\r\n  grid,\r\n  startNode,\r\n  finishNode,\r\n  visitedNodesInOrder\r\n) {\r\n  visitedNodesInOrder.push(startNode);\r\n  startNode.isVisited = true;\r\n\r\n  const unvisitedNeighbors = getUnvisitedNeighbors(startNode, grid);\r\n  for (let neighbors of unvisitedNeighbors) {\r\n    if (neighbors.isWall) continue;\r\n    if (neighbors.isVisited === false) {\r\n      depthFirstSearch(grid, neighbors, finishNode, visitedNodesInOrder);\r\n    }\r\n  }\r\n  let newVisitedNodesInOrder = [];\r\n  for (let i = 0; i < visitedNodesInOrder.length; i++) {\r\n    if (visitedNodesInOrder[i] === finishNode) {\r\n      newVisitedNodesInOrder = visitedNodesInOrder.slice(1, i);\r\n    }\r\n  }\r\n  return newVisitedNodesInOrder;\r\n}\r\n\r\nfunction getUnvisitedNeighbors(node, grid) {\r\n  const neighbors = [];\r\n  const { col, row } = node;\r\n  if (row > 0) neighbors.push(grid[row - 1][col]);\r\n  if (col < grid[0].length - 1) neighbors.push(grid[row][col + 1]);\r\n  if (row < grid.length - 1) neighbors.push(grid[row + 1][col]);\r\n  if (col > 0) neighbors.push(grid[row][col - 1]);\r\n  return neighbors.filter((neighbor) => !neighbor.isVisited);\r\n}\r\n","export function simpleStairPattern(grid, startNode, finishNode) {\r\n  let node1 = grid[28][0];\r\n  let node2 = grid[0][28];\r\n  let node3 = grid[26][56];\r\n  let visitedWallsInOrder = [];\r\n\r\n  for (let i = node1.row, j = node1.col; i !== 0; i--, j++) {\r\n    let currentNode = grid[i][j];\r\n    if (\r\n      currentNode.isWall !== true &&\r\n      currentNode !== startNode &&\r\n      currentNode !== finishNode\r\n    ) {\r\n      visitedWallsInOrder.push(currentNode);\r\n    }\r\n  }\r\n  for (let i = node2.row, j = node2.col; i !== 28; i++, j++) {\r\n    let currentNode = grid[i][j];\r\n    if (\r\n      currentNode.isWall !== true &&\r\n      currentNode !== startNode &&\r\n      currentNode !== finishNode\r\n    ) {\r\n      visitedWallsInOrder.push(currentNode);\r\n    }\r\n  }\r\n  for (let i = node3.row, j = node3.col; j !== 75; i--, j++) {\r\n    let currentNode = grid[i][j];\r\n    if (\r\n      currentNode.isWall !== true &&\r\n      currentNode !== startNode &&\r\n      currentNode !== finishNode\r\n    ) {\r\n      visitedWallsInOrder.push(currentNode);\r\n    }\r\n  }\r\n  return visitedWallsInOrder;\r\n}\r\n","export function simpleMaze(grid, startNode, finishNode, rows, cols) {\r\n  let nodes = [];\r\n  for (let i = 0; i < 600; i++) {\r\n    let row = Math.floor(Math.random() * rows);\r\n    let col = Math.floor(Math.random() * cols);\r\n    let currentNode = grid[row][col];\r\n    if (currentNode !== startNode && currentNode !== finishNode) {\r\n      nodes.push(currentNode);\r\n    }\r\n  }\r\n  return nodes;\r\n}\r\n","import React from \"react\";\nimport PathfindingVisualizer from \"./PathfindingVisualizer/PathfindingVisualizer\";\nimport \"./App.css\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <PathfindingVisualizer />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom/client\";\nimport App from \"./App\";\n\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>\n);\n"],"sourceRoot":""}